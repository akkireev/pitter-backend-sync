import binascii
import hashlib
import secrets

import bcrypt as bcrypt
from django.utils.crypto import constant_time_compare, get_random_string

UNUSABLE_PASSWORD_PREFIX = '!'  # This will never be a valid encoded hash
UNUSABLE_PASSWORD_SUFFIX_LENGTH = 40  # number of random chars to add after UNUSABLE_PASSWORD_PREFIX


def mask_hash(hash, show=6, char="*"):
    """
    Return the given hash, with only the first ``show`` number shown. The
    rest are masked with ``char`` for security reasons.
    """
    masked = hash[:show]
    masked += char * len(hash[show:])
    return masked


class BCryptSHA256PasswordHasher:
    """
    Secure password hashing using the bcrypt algorithm (recommended)
    This is considered by many to be the most secure algorithm but you
    must first install the bcrypt library.  Please be warned that
    this library depends on native C code and might cause portability
    issues.
    """
    algorithm = "bcrypt_sha256"
    digest = hashlib.sha256
    rounds = 12

    def salt(self):
        return bcrypt.gensalt(self.rounds)

    def encode(self, password, salt):
        password = password.encode()
        # Hash the password prior to using bcrypt to prevent password
        # truncation as described in #20138.
        if self.digest is not None:
            # Use binascii.hexlify() because a hex encoded bytestring is str.
            password = binascii.hexlify(self.digest(password).digest())

        data = bcrypt.hashpw(password, salt)
        return "%s$%s" % (self.algorithm, data.decode('ascii'))

    def verify(self, password, encoded):
        algorithm, data = encoded.split('$', 1)
        assert algorithm == self.algorithm
        encoded_2 = self.encode(password, data.encode('ascii'))
        return constant_time_compare(encoded, encoded_2)

    def safe_summary(self, encoded):
        algorithm, empty, algostr, work_factor, data = encoded.split('$', 4)
        assert algorithm == self.algorithm
        salt, checksum = data[:22], data[22:]
        return {
            _('algorithm'): algorithm,
            _('work factor'): work_factor,
            _('salt'): mask_hash(salt),
            _('checksum'): mask_hash(checksum),
        }

    def must_update(self, encoded):
        algorithm, empty, algostr, rounds, data = encoded.split('$', 4)
        return int(rounds) != self.rounds

    def harden_runtime(self, password, encoded):
        _, data = encoded.split('$', 1)
        salt = data[:29]  # Length of the salt in bcrypt.
        rounds = data.split('$')[2]
        # work factor is logarithmic, adding one doubles the load.
        diff = 2 ** (self.rounds - int(rounds)) - 1
        while diff > 0:
            self.encode(password, salt.encode('ascii'))
            diff -= 1


class PasswordHash:
    hasher = BCryptSHA256PasswordHasher()

    @classmethod
    def is_password_usable(cls, encoded):
        """
        Return True if this password wasn't generated by
        User.set_unusable_password(), i.e. make_password(None).
        """
        return encoded is None or not encoded.startswith(UNUSABLE_PASSWORD_PREFIX)

    @classmethod
    def check_password(cls, password, encoded, setter=None):
        """
        Return a boolean of whether the raw password matches the three
        part encoded digest.
        If setter is specified, it'll be called when you need to
        regenerate the password.
        """
        if password is None or not PasswordHash.is_password_usable(encoded):
            return False

        must_update = cls.hasher.must_update(encoded)
        is_correct = cls.hasher.verify(password, encoded)

        # If the hasher didn't change (we don't protect against enumeration if it
        # does) and the password should get updated, try to close the timing gap
        # between the work factor of the current encoded password and the default
        # work factor.
        if not is_correct and must_update:
            cls.hasher.harden_runtime(password, encoded)

        if setter and is_correct and must_update:
            setter(password)
        return is_correct

    @classmethod
    def make_password(cls, password, salt=None):
        """
        Turn a plain-text password into a hash for database storage
        Same as encode() but generate a new random salt. If password is None then
        return a concatenation of UNUSABLE_PASSWORD_PREFIX and a random string,
        which disallows logins. Additional random string reduces chances of gaining
        access to staff or superuser accounts. See ticket #20079 for more info.
        """
        if password is None:
            return UNUSABLE_PASSWORD_PREFIX + get_random_string(UNUSABLE_PASSWORD_SUFFIX_LENGTH)
        hasher = BCryptSHA256PasswordHasher()
        salt = salt or hasher.salt()
        return hasher.encode(password, salt)

    @classmethod
    def mask_hash(cls, hash, show=6, char="*"):
        """
        Return the given hash, with only the first ``show`` number shown. The
        rest are masked with ``char`` for security reasons.
        """
        masked = hash[:show]
        masked += char * len(hash[show:])
        return masked
